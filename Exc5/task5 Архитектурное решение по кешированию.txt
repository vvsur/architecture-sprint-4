### Ответ на Задание 5: Кэширование

---

#### **Обновление/сброс кэша при изменении статуса заказа через брокера**

На sequence diagram неясно указано, как именно происходит обновление или сброс кэша при изменении статуса заказа через брокера сообщений (например, RabbitMQ). Для устранения этой неопределенности предлагается следующая логика работы системы:

---

### **Процесс обновления/сброса кэша через брокера**

1. **Обновление статуса заказа:**
   - Когда MES или CRM обновляют статус заказа, событие об изменении статуса отправляется в брокер сообщений (RabbitMQ).
   - Событие включает идентификатор заказа (`OrderID`), новый статус и timestamp изменения.

2. **Обработка события брокером:**
   - Сообщение доставляется в подписанный на очередь компонент (например, сервис обновления кэша).

3. **Сервис обновления кэша:**
   - Компонент проверяет, находится ли заказ с данным `OrderID` в кэше.
   - Если заказ найден:
     - Запись в кэше обновляется с новым статусом.
   - Если заказ отсутствует:
     - Ничего не меняется, так как данные неактуальны для текущего кэша.

4. **Инвалидация записи в кэше:**
   - Если кэширование реализовано через паттерн **Write-Through**, запись в кэше синхронизируется с базой данных.
   - Если используется **Read-Through**, запись в кэше инвалидация автоматически, и при следующем запросе данные подтягиваются из базы данных.

5. **Механизм TTL (Time-To-Live):**
   - Для обеспечения актуальности данных TTL помогает автоматически удалять устаревшие записи, если их статус не обновляется в течение заданного времени.

---

### **Sequence Diagram для обновления кэша через брокер**

1. **Инициатор:** CRM или MES (изменяют статус заказа).
2. **RabbitMQ:** Передача сообщения об изменении статуса.
3. **Сервис обновления кэша:**
   - Проверка существующей записи.
   - Обновление или инвалидация записи.
4. **Redis:** Обновление записи в кэше или удаление старых данных.
5. **Ответ:** Подтверждение успешного обновления кэша.

---

### **Рекомендуемые улучшения Sequence Diagram**

1. **Добавить шаги:**
   - Событие от CRM/MES в RabbitMQ.
   - Обработка события в сервисе обновления кэша.
   - Действие в Redis: обновление или инвалидация записи.

2. **Синхронизация:**
   - Убедиться, что изменения в кэше происходят синхронно с обновлением статуса заказа в базе данных.

3. **Обработка ошибок:**
   - Предусмотреть сценарии, если сообщение от RabbitMQ потеряно или Redis временно недоступен:
     - Повторная отправка сообщений (retry).
     - Логирование ошибок и fallback на базу данных.

---

Обновление или сброс кэша при изменении статуса заказа из брокера должно происходить через специальный сервис обновления кэша, интегрированный с RabbitMQ. Sequence Diagram должна быть дополнена шагами передачи событий от RabbitMQ в Redis, чтобы показать процесс управления кэшем. Это обеспечит согласованность данных между кэшем и базой, снизит риск устаревания информации и повысит производительность.